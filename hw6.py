# -*- coding: utf-8 -*-
"""Hw6.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bMffUZdrddQuwU1Bc-z0MD1nLLeE7Kvc
"""

import math, time, copy
import numpy as np
from sklearn import datasets
import matplotlib.pyplot as plt
from matplotlib import gridspec

np.random.seed(0)

#from google.colab import drive
#drive.mount('/content/drive')
#datapath = '/content/drive/MyDrive/'
datapath = "./"

#################### Task 1 ###################
# Implement PCA
# You should be able to implement your own PCA by using numpy only.
# draw a vector
def vector_draw(vec,ax,**kwargs):
    color = 'k'
    if 'color' in kwargs:
        color = kwargs['color']
    zorder = 3
    if 'zorder' in kwargs:
        zorder = kwargs['zorder']

    veclen = math.sqrt(vec[0]**2 + vec[1]**2)
    head_length = 0.25
    head_width = 0.25
    vec_orig = copy.deepcopy(vec)
    vec = (veclen - head_length)/veclen*vec
    ax.arrow(0, 0, vec[0],vec[1], head_width=head_width, head_length=head_length, fc=color, ec=color,linewidth=3,zorder = zorder)


def pca_visualizer(X,W,pcs):
    # renderer
    fig = plt.figure(figsize = (15,5))

    # create subplot with 3 panels, plot input function in center plot
    gs = gridspec.GridSpec(1, 2)
    ax1 = plt.subplot(gs[0],aspect = 'equal');
    ax2 = plt.subplot(gs[1],aspect = 'equal');

    # sphere the results
    ars = np.eye(2)

    # loop over panels and plot each
    c = 1
    for ax,pt,ar in zip([ax1,ax2],[X,W],[pcs,ars]):
        # set viewing limits for originals
        xmin = np.min(pt[0,:])
        xmax = np.max(pt[0,:])
        xgap = (xmax - xmin)*0.15
        xmin -= xgap
        xmax += xgap
        ymin = np.min(pt[1,:])
        ymax = np.max(pt[1,:])
        ygap = (ymax - ymin)*0.15
        ymin -= ygap
        ymax += ygap

        # scatter points
        ax.scatter(pt[0,:],pt[1,:],s = 60, c = 'k',edgecolor = 'w',linewidth = 1,zorder = 2)

        # plot original vectors
        vector_draw(ar[:,0].flatten(),ax,color = 'red',zorder = 3)
        vector_draw(ar[:,1].flatten(),ax,color = 'red',zorder = 3)

        # plot x and y axes, and clean up
        ax.grid(True, which='both')
        ax.axhline(y=0, color='k', linewidth=1.5,zorder = 1)
        ax.axvline(x=0, color='k', linewidth=1,zorder = 1)
        ax.set_xlim([xmin,xmax])
        ax.set_ylim([ymin,ymax])
        ax.grid('off')

        # set tick label fonts
        for tick in ax.xaxis.get_major_ticks():
            tick.label.set_fontsize(12)
        for tick in ax.yaxis.get_major_ticks():
            tick.label.set_fontsize(12)

        # plot title
        if c == 1:
            ax.set_title('Original data')
            ax.set_xlabel(r'$x_1$')
            ax.set_ylabel(r'$x_2$',rotation = 0,labelpad = 10)
        if c == 2:
            ax.set_title('Encoded data')
            ax.set_xlabel(r'$c_1$')
            ax.set_ylabel(r'$c_2$',rotation = 0,labelpad = 10)
        c+=1

def center(X):
  X_means = np.mean(X, axis=1)[:, np.newaxis]
  X_normalized = X - X_means

  return X_normalized

def compute_pcs(X,lam):
  P = float(X.shape[1])
  Cov = 1/P*np.dot(X,X.T) + lam*np.eye(X.shape[0])
  D,V = np.linalg.eigh(Cov)
  return D,V

def pca_transform_data(X,**kwargs):
  num_components = X.shape[0]
  if 'num_components' in kwargs:
    num_components = kwargs['num_components']
  lam = 10**(-7)
  if 'lam' in kwargs:
    lam = kwargs['lam']

  D,V = compute_pcs(X,lam)
  V = V[:, -num_components:]
  D =  D[-num_components:]

  W = np.dot(V.T,X)
  return W,V

def run_task1():
	# load in dataset
	csvname = datapath + '2d_span_data.csv'
	x = np.loadtxt(csvname, delimiter = ',')

	print(np.shape(x)) # (2, 50)

    # TODO: fill in your code
  # Center the data
	x_centered = center(x)

  # Compute PCA and get principal components
	W, V = pca_transform_data(x_centered, num_components=2)

  # Plot the mean-centered data along with principal components
	pca_visualizer(x_centered,W,V)
	plt.show()

#################### Task 2 ###################

# Implement K-Means;
# You should be able to implement your own kmeans by using numpy only.
# function for updating cluster assignments
def update_assignments(data,centroids):
    P = np.shape(data)[1]
    assignments = []
    for p in range(P):
        # get pth point
        x_p = data[:,p][:,np.newaxis]

        # compute distance between pth point and all centroids
        # using numpy broadcasting
        diffs = np.sum((x_p - centroids)**2,axis = 0)

        # determine closest centroid
        ind = np.argmin(diffs)
        assignments.append(ind)
    return np.array(assignments)

# update centroid locations
def update_centroids(data,old_centroids,assignments):
    K = old_centroids.shape[1]
    # new centroid container
    centroids = []
    for k in range(K):
        # collect indices of points belonging to kth cluster
        S_k = np.argwhere(assignments == k)

        # take average of points belonging to this cluster
        c_k = 0
        if np.size(S_k) > 0:
            c_k = np.mean(data[:,S_k],axis = 1)
        else:  # what if no points in the cluster?  keep previous centroid
            c_k = copy.deepcopy(old_centroids[:,k])[:,np.newaxis]
        centroids.append(c_k)
    centroids = np.array(centroids)[:,:,0]
    return centroids.T

# main k-means function
def my_kmeans(data,centroids,max_its):
    # outer loop - alternate between updating assignments / centroids
    for j in range(max_its):
        # update cluter assignments
        assignments = update_assignments(data,centroids)

        # update centroid locations
        centroids = update_centroids(data,centroids,assignments)

    # final assignment update
    assignments = update_assignments(data,centroids)
    return centroids,assignments

def compuate_ave(data, centroids, assignments):
    P = assignments.size  # Use the size attribute to get the number of elements
    K = np.max(assignments) + 1  # Calculate the number of clusters from assignments
    error = 0
    for k in range(K):
        ind = np.argwhere(assignments == k)
        if np.size(ind) > 0:
            ind = [s[0] for s in ind]
            for i in ind:
                pt = data[:, i]
                centroid = centroids[:, k]  # Get the centroid for cluster k
                error += np.linalg.norm(centroid - pt)
    # Divide by the average
    error /= float(P)
    return error

def scree_plot(data, K_range, max_its):
    # Initialize an empty list to store the objective values for each K
    K_errors = []

    for k in K_range:
        errors = []
        for j in range(5):
            # Initialize
            P = np.shape(data)[1]
            random_inds = np.random.permutation(P)[:k]
            init_centroids = data[:, random_inds]

            # Run K-means algo
            centroids, assignments = my_kmeans(data, init_centroids, max_its)

            # Compute average error over the dataset
            error = compuate_ave(data, centroids, assignments)
            errors.append(error)

        # Take the final error
        best_ind = np.argmin(errors)
        K_errors.append(errors[best_ind])

    # Plot cost function value for each K chosen
    plt.plot(K_range, K_errors, 'ko-')
    plt.title('Cost value')

    # Dress up the panel
    plt.xlabel('Number of clusters')
    plt.xticks(K_range)
    plt.show()

def run_task2():

	# Loading the data
	P = 50 # Number of data points
	blobs = datasets.make_blobs(n_samples = P, centers = 3, random_state = 10)
	data = np.transpose(blobs[0])
	print(data.shape) # (2, 50)k

  # TODO: fill in your code
  # initialize centroids as random points, pick a number
  # clusters K to try, and set maximum iterations
	r = np.arange(np.shape(data)[1])
	num_clusters = 3
	pts = np.random.permutation(r)[:num_clusters]
	iniit_centroids = data[:,pts]
	max_its = 10

	# run k-means implementation above
	centroids,assignments = my_kmeans(data,iniit_centroids,max_its)
  # Scatter plot the dataset with different colors for each cluster
	colors = ['r', 'g', 'b']
	for k in range(num_clusters):
		cluster_points = data[:, np.where(assignments == k)[0]]
		plt.scatter(cluster_points[0, :], cluster_points[1, :], c=colors[k], label=f'Cluster {k + 1}')

  # Plot centroids with labels
	for k in range(num_clusters):
		plt.scatter(centroids[0, k], centroids[1, k], c='k', marker='x')
		plt.text(centroids[0, k], centroids[1, k], f'Centroid {k + 1}')


	plt.legend()
	plt.show()

	K_range = [1,2,3,4,5,6,7,8,9,10]
	scree_plot(data,K_range,max_its = 10)

if __name__ == '__main__':
	run_task1()
	run_task2()
